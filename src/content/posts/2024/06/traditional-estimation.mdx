---
title: "Think of a number...and double it"
postDate: 2024-06-20
draft: true
description: >-
  Since I do a lot of pre-sales the agile relative estimation techniques don't work so I have to resort to traditional estimation methods. This is how I make sure new projects are estimated accurately.
image:
  src: "./1508048708_c15cf0d9fe_k.jpg"
  alt: "A serene and tranquil scene of the ocean meeting the sky at the horizon. It is characterized by its simplicity, with clear blue waters below and a lighter blue sky above. The lower part of the image is dominated by the ocean, characterized by its rich turquoise color. The waters appear calm with subtle waves, reflecting light to give it a sparkling effect. Above the ocean lies an expansive sky, transitioning from a deeper blue at the top to a lighter shade as it meets the horizon. It’s clear and free of clouds, contributing to the overall peacefulness of the scene. The central focus is where the ocean meets the sky – forming a distinct yet soft horizon line that separates yet unites these two dominant elements."
categories:
  - "pre-sales"
tags:
  - "estimation"
  - "opinion"
---
import Aside from '@components/Aside.astro';

## Introduction

Traditional estimation techniques still have a place especially during pre-sales where there isn't a team or any delivery history available. 

## Relative Estimation in a Traditional Way

The first step is to break things down into small pieces but I have to assume at this point you have a solution you plan to deliver. You can break this into a series of layers and elements in each one:

- Infrastructure - these are the empty slots your application code fits into. Don't forget things like identity, networking, management, configuration, secrets, monitoring, ingress/egress etc. Having an existing landing zone saves you a lot of time. Make sure you include all your environments from dev to live.
- Build and Release - the tooling that takes you from requirements to production. Think work item tracking, wikis, source code repositories, build and release pipelines, artifact repositories, test planing and results.
- Support and operations - tooling for incident, problem and change management; documentation for support staff, end users, compliance, etc;
- Application Skeleton - a list of all the empty projects and solutions, dependencies and other work required to build a "zero feature" application.

We will add the application features later. The list above depends on your solution but doesn't change as you add more features.

<Aside type="tip" title="Platform Engineering">
Organizations that have a platform engineering approach can reap huge benefits since the "platform" will already have the capabilities needed by the these items baked in and deployable at the push of a button or command line. Their estimates are therefore much smaller.
</Aside>

Once you have the list of elements you are planning to create, group them by type and add to an Excel workbook along with the count of each type.

(factors)

## Volume Discounts

(pert analysis)

## Adjusting for Confidence and Risk

variance

## What about the rest?

ratios of build to other

## Summary
